---
layout: default
---
 <!-- MAIN CONTENT -->
<div class="main_content_wrap outer">
  <section class="main_content inner">
    <h2>Scraping Web Content</h2>
    <a id="february-28-2015" class="anchor" href="#february-28-2015" aria-hidden="true"><span class="octicon octicon-link"></span></a>February 28, 2015</h3>

    <p>Today, I got to work with a friend to use Python libraries to scrape data from a Pokemon website
        [http://bulbapedia.bulbagarden.net/wiki/].
        Since there's a lot of data and numbers associated with it,
        I thought it'd be fun to look into and explore. [Disclaimer: I do not play Pokemon and the most I know is that
        Pikachu is a very famous(?) Pokemon]</p>

    <p>The python packages needed are: <code>lxml</code> for HTML parsing and <code>urllib</code>
        to access the url as a HTML response.<p>
    <code>url = {url_name} <br>
        response = urllib.urlopen(url) <br>
        data = response.read() <br>
        tree = html.fromstring(data) <br>
    </code>
    <p>Essentially, we need to access the DOM element from which we want to scrap data using the xpath that leads to it. So if you've ever stumbled upon this path, </p>
    <p class="thick">Right click web-page -> Inspect Element -> Right on the HTML for the element you are searching, you'll notice an option called ->'Copy Xpath'.</p>
    <p>Unfortunately, it won't work in some cases where the content you are searching for is in within a <code>table</code> tag.
    On inspecting the xpath, I noticed the <code>tbody</code> tag, which are tags inserted
    by the browser when not specified in the source code. So, I had to restructure the path, removing the tbody tags. </p>
    <p>
    Here's the xpath information for accessing a span element whose id is "By_leveling_up", going up to the parent node, accessing a sibling node
      and then traversing down 2 nested tables using indexes and accessing the content from the td element at index "13" for all the tr elements in
      that table.
    </p>
    <p class="text_width">
     <pre> tree.xpath('//span[@id="By_leveling_up"]/../following-sibling::table[1]/
         tr[2]/td[1]/table[1]/tr/td[13]/a/span/text()')</pre>
    <p>
  </section>
</div>

<!-- MAIN CONTENT -->
<div class="main_content_wrap outer">
  <section class="main_content inner">
    <h2>Fun with Shell Scripting</h2>
    <a id="february-21-2015" class="anchor" href="#february-21-2015" aria-hidden="true"><span class="octicon octicon-link"></span></a>February 21, 2015</h3>

    <p>After my early morning run at 7 a.m., I was inspired to use and setup a github page for my profile; so here goes.
        I hope to update this page psuedo blog style page with code snippets or interesting links that I come across.</p>
    <p>For today, I wanted to include a calendar here to kinda mark when I started.
        I defaulted to use the simplest shell script that I thought of : <code>$ CAL</code> </p>
    <div id="screen_shot_1">
        <img class="text_width" src='./images/cal_uc_shell_script.png'>
    </div>
    <p>Oops, CAPS lock was turned on. It gave me an interesting result with the days oriented vertically, not what I wanted though.
        Try 2 : <code>$ cal</code></p>
    <div id="screen_shot_2">
        <img class="text_width" src='./images/cal_lc_shell_script.png'>
    </div>
    <p>Hmm, I thought it would highlight "today". I was suprised to find out that <code>cal</code> in OSX <strong>doesn't</strong> highlight today by default.
        So, here's where I learnt a cool new script to make highlighting work!</p>
        <code>$cal | grep -C3 --color " $(date +%-d)"</code>
    <div id="screen_shot_3">
        <img class="text_width" src='./images/cal_highlight_script.png'>
    </div>
    <p>Oh, I created an alias for it as well.</p> <code>$alias today='cal | grep -C3 --color " $(date +%-d)"'</code>
  </section>
</div>

<!-- MAIN CONTENT -->
<div class="main_content_wrap outer">
  <section class="main_content inner">
    <h2>Unzip a file in-memory, add content, and zip it back up</h2>
    <a id="may-6-2014" class="anchor" href="#may-6-2014" aria-hidden="true"><span class="octicon octicon-link"></span></a>May 6, 2014</h3>

    <p>As a part of making the deployment process easy, I was involved in a project where our software needed to be prefilled with authentication credentials per customer basis. All this functionality had to be implemented at the view level which required the file to be unzipped into a memory buffer, modified and zipped back. This needed 2 iterations<p></p> Python has a very useful ZipFile library for this purpose to read/write zipped files in memory.</p>
    <pre>
        zipped_file # This contains the zipped file
        file_content_buffer = StringIO() # in_memory buffer
        config_filepath = '/sample.conf'
        with ZipFile(zipped_file, 'r') as zipread:
            with ZipFile(file_content_buffer, 'w', ZIP_DEFLATED) as zipwrite:
                for item in zipread.infolist():
                    if item.filename.endswith(config_filepath):
                        credentials = 'xxxxx-top-secret'
                        zipwrite.writestr(item.filename, credentials)
                    else:
                        # copy the data over as is
                        data = zipread.read(item.filename)
                        zipwrite.writestr(item.filename, data)
        file_content_buffer.seek(0)

        response = HttpResponse(file_content_buffer.getvalue())
        response['Content-Disposition'] = 'attachment; filename=custom_zipped_file.zip'
        response['Content-Type'] = 'application/x-zip'
        return response
    </pre>
    <p>This worked well until I tested it out, only to find out that several of the <strong>symlinks</strong> within the zipped file dont get copied over. They appear as broken files with 0kb size. After a lot of research, it looks like the file properites dont get preserved hence rendering the file broken. This also manifests in the created timestamp where it's set to epoch 0. So, the following changes had to keep the file in tact.

      <pre>
        with ZipFile(zipped_file, 'r') as zipread:
            with ZipFile(file_content_buffer, 'w', ZIP_DEFLATED) as zipwrite:
                for item in zipread.infolist():
                    # Copy all ZipInfo attributes for each file since by
                    # default the properties are not preserved.
                    dest = ZipInfo(item.filename)
                    dest.CRC = item.CRC
                    dest.date_time = item.date_time #sets the date modified correctly
                    dest.create_system = item.create_system
                    dest.compress_type = item.compress_type
                    dest.external_attr = item.external_attr # preserves symlinks
                    dest.compress_size = item.compress_size
                    dest.file_size = item.file_size
                    dest.header_offset = item.header_offset
                    if item.filename.endswith(config_filepath):
                        # Sets up config file with valid credentials
                        zipwrite.writestr(dest, credentials)
                    else:
                        data = zipread.read(item.filename)
                        zipwrite.writestr(dest, data)
        file_content_buffer.seek(0)
      </pre>    
  </section>
</div>

<!-- MAIN CONTENT -->
<div class="main_content_wrap outer">
  <section class="main_content inner">
    <h2>Querystring creation using Jquery.param </h2>
    <a id="february-24-2014" class="anchor" href="#february-24-2014" aria-hidden="true"><span class="octicon octicon-link"></span></a>February 24, 2014</h3>

    <p>Being a backend engineer, I didn't seem to care too much about best practices when coding in Jquery or any front end technology for that matter<p></p> It, in most cases, made my code bulky and error prone. This was easily obvious when I refactored a simple implementation of serializing params to create a queyrstring.</p>
    <pre>
        var startParam = 'start=' + start,
            stopParam = 'stop=' + stop,
            dateParam = 'date=' + date,
            params = startParam + '&' + stopParam + '&' + dateParam;
    </pre>
    <p>Since this serialization is done by pure string formatting, there can be edge cases where an & or other characters that need to be escaped are passed in the query string. Why bother when there are libraries for this purpose :) I went ahead and refactored it by using <code> jquery.param</code> </p>

      <pre>
        var paramsDict = { startParam: start,
                            stopParam: stop,
                            dateParam: date };
        var params = $.param( paramsDict );
      </pre>    
  </section>
</div>

<!-- MAIN CONTENT -->
<div class="main_content_wrap outer">
  <section class="main_content inner">
    <h2>Path direction </h2>
    <a id="february-15-2014" class="anchor" href="#february-15-2014" aria-hidden="true"><span class="octicon octicon-link"></span></a>February 15, 2014</h3>

    <p>After having played more with the algorithm to identify if paths(lines) intersect, I was curious to figure out based on the angle made at the point of intersection if a sense of direction could be attributed to the path<p></p> For instance, if the path intersects from left to right or right to left in relation to the x axis.</p>
    <p> A quick and dirty solution is just using <code>arctan</code> to find the angle at the point of intersection. If positive, the angle was made in the 1st or 2nd quadrant which signifies where the origin of the path lies. Else, the angle was made in the 3rd or 4th quadrant.
    <p>
    For instance, consider a line represented by line_start,line_end each a tuple of ints[x,y] and a path that intersect the line represented by path_start, path_end which is also a tuple of ints. 
    Here below is the code in python using library <code>math</code>

      <pre>
        xdiff = line_start[0]-path_start[0]
        ydiff = line_start[1]-path_start[1]
        if degrees(atan2(ydiff, xdiff)) > 0:
            left_to_right += 1
        else:
            right_to_left += 1
      </pre>
  </section>
</div>

<!-- MAIN CONTENT -->
<div class="main_content_wrap outer">
  <section class="main_content inner">
    <h2>Finding if 2 lines intersect given their coordinates</h2>
    <a id="february-14-2014" class="anchor" href="#february-14-2014" aria-hidden="true"><span class="octicon octicon-link"></span></a>February 14, 2014</h3>

    <p>In one of the projects I was working on, I was given a task to calculate the total number of paths(lines) that cross another line. This could be further broken down into finding the number of intersections made with the line of interest.</p>

    <p>Let me begin by explaining the solution before including Python.</p>
    <pre>Src: <a href="http://compgeom.cs.uiuc.edu/~jeffe/teaching/373/notes/x06-sweepline.pdf">http://compgeom.cs.uiuc.edu/~jeffe/teaching/373/notes/x06-sweepline.pdf</a></pre></br><h5> Explanation: </h5> 
    <p>Given 2 lines AB and CD, they intersect if and only if A and B are separated by segment CD and vice-versa. If so, ACD and BCD should have opposite orientation which means only one can be counterclockiwise.</p>
    <p>Determining the orientation of points can be done by using slopes. If slope of AB is less than AC, then ABC are listed in the counterclockwise order. </p>
    
    <pre>def ccw(A,B,C): 
    return (B[1]-A[1])/(B[0]-A[0]) < (C[1]-A[1])/(C[0]-A[0])  
    </pre></p>
    <pre>def intersect(A,B,C,D):
    return ccw(A,C,D) != ccw(B,C,D) and ccw(A,B,C) != ccw(A,B,D)
    </pre>
  </section>
</div>


